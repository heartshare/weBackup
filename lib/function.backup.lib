#!/bin/bash
#	Backup function library for Backup Script 
#
#	Version: 0.5

#
##  FUNCTION DECLARATION
#

function usage () {
  echo -e "Usage: $0 [OPTIONS] [COMMAND]"
  echo -e "OPTIONS must be specified before COMMAND to be correctly executed."
  echo -e "Settings are defined in the file 'config' in the script folder ( edit before first run )."
  
  echo -e "\nOPTIONS:"
  
  echo -e "  --debug, -d"
  echo -e "    Prevent execution of rdiff-backup command and prints out on stdout the command that would be executed ( useful in testing )."
  
  echo -e "  --mail, -m"
  echo -e "    Send mail with debug informations. Useful with -d to send a report mail with debug, which by default disable mail sending."
  
  echo -e "  --verbose, -v"
  echo -e "    Prints out info on backup status; by default the script run in 'quiet' mode, so that no output is printed on stdout ( this mainly because is unuseful to have stdout in a cronjob ); whit verbose is possible to enable stdout output."
  
  echo -e "  --version"
  echo -e "    Print script version."
    
  echo -e "\nCOMMAND:"
  echo -e "  --backup, -b"
  echo -e "    Execute backup on defined servers/folders."
  
  echo -e "  --restore, -r [ NOT IMPLEMENTED ]"
  echo -e "    Execute restore of backups."
  exit;
}

function trap_err_function() {
  exit_status=$?
    echo -e "\n*** WARNING LINE "$1": Command exited with status "$exit_status" ***\n"
}

function trap_exit_function() {
  exit_status=$?
    echo -e "\n*** FATAL ERROR LINE "$1": Command exited with status "$exit_status" ***\n"
}


# Handling function for command line arguments
function exec_backup() {
  test_logrotate
  backup

  if [ $VERBOSE -eq 1 ]; then
    df -h | tee -a $LOG
  else
    df -h >> $LOG
  fi
  
  if [ ! $DEBUG -eq 1 ]; then
    send_mail
  elif [[ $MAIL -eq 1 ]]; then
    send_mail
  fi
  archive_log
}

function print_version() {
  echo "Backup Script version: "$VERSION
  echo "rdiff-backup local version: "$(rdiff-backup --version)
}

function set_debug() {
  echo "Debug Mode Enabled" | tee -a $LOG
  DEBUG=1
}

function set_mail() {
  echo "Mail Mode Forced" | tee -a $LOG
  MAIL=1
}

function set_verbose() {
  echo "Verbose Mode Enabled" | tee -a $LOG
  VERBOSE=1
}

# backup (  )
# The main backup function. Tass!
function backup() {
	
	if [[ ! $(ls -A $CONF_DIR) ]]; then
		echo ""
		echo "No host file specified in '$CONF_DIR'"
		echo "Stopping backup"
		echo ""
		exit
	fi

	if [ $VERBOSE -eq 1 ]; then
	  log "Backup local disk: $BACKUP_DIR" 1 1
		log "Backup local conf: $CONF_DIR" 1 1
		log "Log file         : $LOG" 1 1
	
		log "Hosts:"
		for host in `ls $CONF_DIR`
		do
		  #Parsing the various hosts, ignore the template file plz
		  if [ $host == 'template.tpl' ]; then
		    continue
	    fi
		  test_conf_dir $host
			log "$host" "" 1
		done
		
		echo -n "Startin backup"
		backup_delay $DELAY 1
	else
		backup_delay $DELAY 0
	fi

	for host in `ls $CONF_DIR`
	do
	  #Parsing the various hosts, ignore the template file plz
	  if [ $host == 'template.tpl' ]; then
	    continue
    fi

	  test_conf_dir $host #test if both per host conf files exists
	  . ${CONF_DIR}/${host}/host.conf #then source one of them
	  if [ $DEBUG -eq 1 ]; then
  	  log "Using $host configuration" "" 1
	  fi

    #if i have a per host retention setting
    if [[ ${servconf[5]} ]]; then
      #than set it for further use
      __ret=${servconf[5]}W
    else
      #else set it to the global retention setting
      __ret=${RETENTION}
    fi
	  
	  if ${servconf[0]}; then #if remote
  	  user="${servconf[1]}@" #set the proper username
	  else #if local
	    user="" #no username needed
	    # For remotly mounted sshfs file systems we'll
	    #+have an ad hoc username from host.conf
    fi
	  
		if [ $VERBOSE -eq 1 ]; then
			log "Inizio Backup per: $host\n" 1 1
		fi
		
		##STARTS DEBUG ONLY TASKS
		if [ ! $DEBUG -eq 1 ]; then
			dest_dir $host
		else
		  if ${servconf[0]}; then #if remote
		    log "TESTING $host" "" 1
			  log "rdiff-backup --print-statistics --exclude-special-files --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf --exclude / ${user}${host}::/ ${BACKUP_DIR}/${host}" 1 1
			  logcmd "rdiff-backup --test-server ${user}${host}::/" 1 1
		  else #if local
        if ${servconf[3]}; then #if a remotely mounted sshfs filesystem
          mount_sshfs ${user}${host}::/ ${servconf[2]}
        fi
        log "TESTING mountpoint /mnt/$host" "" 1
        mountpoint ${servconf[2]} > /dev/null
        if [[ $? != 0 ]]; then
          log "ERROR: mount of the remote filesystem went bad; problem probably genereted remotly. Aborting" "" 1
	      fi
      fi
		fi
		##END DEBUG ONLY TASKS
		
		##START SERIUS BACKUP
		if [ ! $DEBUG -eq 1 ]; then
		  #If verbose AND remote
			if [ $VERBOSE -eq 1 ] && ${servconf[0]}; then
        if [[ ${servconf[4]} ]]; then
          logcmd "rdiff-backup --print-statistics --exclude-special-files --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf ${user}${host}::${servconf[4]} ${BACKUP_DIR}/${host}" 1 1
				  logcmd "rdiff-backup --force --remove-older-than ${__ret} ${BACKUP_DIR}/${host}" "" 1
        else
          logcmd "rdiff-backup --print-statistics --exclude-special-files --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf --exclude / ${user}${host}::/ ${BACKUP_DIR}/${host}" 1 1
          logcmd "rdiff-backup --force --remove-older-than ${__ret} ${BACKUP_DIR}/${host}" "" 1
        fi
			#else if verbose AND local
			elif [ $VERBOSE -eq 1 ] && ! ${servconf[0]}; then
			  # If my dir is a sshfsmounted dir than handle mount
			  #+operations with the proper function
			  if ${servconf[3]}; then
          if ! mount_sshfs; then continue; fi 
        fi
			  logcmd "rdiff-backup --print-statistics --exclude-special-files --verbosity $RDIFF_VERBOSITY --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf ${servconf[2]} ${BACKUP_DIR}/${host}" 1 1
				logcmd "rdiff-backup --force --remove-older-than ${__ret} ${BACKUP_DIR}/${host}" "" 1
        
		  else # else if remote but NOT verbose
			  if ${servconf[0]}; then #if remote
          if [[ ${servconf[4]} ]]; then
            logcmd "rdiff-backup --verbosity $RDIFF_VERBOSITY --print-statistics --exclude-special-files --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf ${user}${host}::${servconf[4]} ${BACKUP_DIR}/${host}" 1
				    logcmd "rdiff-backup --force --remove-older-than ${__ret} ${BACKUP_DIR}/${host}" 1
          else
            logcmd "rdiff-backup --verbosity $RDIFF_VERBOSITY --print-statistics --exclude-special-files --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf --exclude / ${user}${host}::/ ${BACKUP_DIR}/${host}" 1
            logcmd "rdiff-backup --force --remove-older-than ${__ret} ${BACKUP_DIR}/${host}" 1
        fi
			  else #if local
			    if ${servconf[3]}; then
            if ! mount_sshfs; then continue; fi
          fi
			    logcmd "rdiff-backup --verbosity $RDIFF_VERBOSITY --print-statistics --exclude-special-files --include-globbing-filelist ${CONF_DIR}/${host}/globbing.conf ${servconf[2]} ${BACKUP_DIR}/${host}" 1
				  logcmd "rdiff-backup --force --remove-older-than ${__ret} ${BACKUP_DIR}/${host}" 1
			  fi
			fi
		fi
		
		# If we have $mounted true, so we have to unmount the dir
		if [[ $mounted ]]; then
		  `which fusermount` -u ${servconf[2]}
		  log "Unmounted ${servconf[2]}"
		  # and unset it
		  unset mounted
	  fi
	done
}

# test_conf_dir ( host )
# Test if the needed config files exist
function test_conf_dir(){
  if [ ! -f ${CONF_DIR}/$1/globbing.conf ] || [ ! -f ${CONF_DIR}/$1/host.conf ]; then
    log "Missing configuration files for host ${1}. Aborting"
    exit 1
  fi
  
  return 0
}

# dest_dir ( string name )
# Test if backup destination directory exists and if not
#+create it.
function dest_dir() {
	local dir=${BACKUP_DIR}/${1}
	
	if [ -d $dir ]; then
		if [ $VERBOSE -eq 1 ]; then
			echo "> Backup directory for host exists" | tee -a $LOG
		fi
	else
		if [ $VERBOSE -eq 1 ]; then
			echo "> Backup directory for host does not exists; creating..." | tee -a $LOG
		fi
		
		mkdir $dir
		
		if [ -d $dir ]; then
			if [ $VERBOSE -eq 1 ]; then
				echo "> Created: "$dir | tee -a $LOG
			fi
		else
			echo "> FAILED! Backup ABORTED ( err: "$?" )" | tee -a $LOG
			exit $?
		fi
	fi
	
	return 0
}

# delay ( int time, bool stdout )
function backup_delay() {
	local delay_time=$1
	local stdout=$2
	
	for i in `seq $delay_time -1 1`
	do
		if [ $stdout -eq 1 ]; then
			echo -e -n "."
		fi
		sleep 1
	done
	
	if [ $stdout -eq 1 ]; then
		echo -e "\n"
	fi
}

# mount_sshfs ( user@host:dir mountpoint )
# This function will be valid only inside backup() function
#+due to use of certain variables setted there...
function mount_sshfs(){
  if ! ${servconf[0]}; then
    if ${servconf[3]}; then
      if [[ ! `which sshfs` ]]; then
        log "FATAL: sshfs is not installed on the system. Aborting... \n try apt-get install sshfs" 1
        return 1
      fi
      
      if [[ ! -d ${servconf[2]} ]]; then mkdir ${servconf[2]}; fi

      # If at this point for any reason of the hell the mountpoint is already mounted, unmount it
      #+befor the nect mount
      if mountpoint ${servconf[2]}; then
        `which fusermount` -u ${servconf[2]};
        log "Unmounted ${servconf[2]}: it was already mounted for some reason"
      fi
      
      `which sshfs` ${servconf[1]}@${host}:${servconf[4]} ${servconf[2]} -C
      
      if [[ $? != 0 ]]; then
        log "FATAL: mount of the remote filesystem went bad; problem probably genereted remotly. Aborting"
        return 1
      fi
      mountpoint ${servconf[2]} #double control of the mount is paranoic?
      if [[ $? != 0 ]]; then
        log "FATAL: mount of the remote filesystem went bad; problem probably genereted remotly. Aborting"
        return 1
      else
        # At the end of the backup process will be a pleasure to have a quick way to verify
        #+if the dir is alredy mounted to unmount it before process another host/dir.
        #+Only to minimize risks that someone could have access to the remote files from the backup server
        #+and potentially put the word END on clients data... >_>
        mounted=true
      fi
    fi
  fi
  return 0
}

